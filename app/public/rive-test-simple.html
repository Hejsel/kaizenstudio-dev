<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Rive Test</title>
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
        }
        canvas {
            width: 100%;
            max-width: 600px;
            height: 400px;
            border: 2px solid #ccc;
            display: block;
            margin: 20px 0;
        }
        .info {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        pre {
            background: #333;
            color: #0f0;
            padding: 10px;
            overflow-x: auto;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Simple Rive Test</h1>

    <div class="info">
        <p><strong>Status:</strong> <span id="status">Loading...</span></p>
    </div>

    <div class="info">
        <label for="fileSelect"><strong>V√¶lg .riv fil:</strong></label>
        <select id="fileSelect" style="padding: 8px; font-size: 16px; width: 100%;">
            <optgroup label="Your Files">
                <option value="http://kaizenstudio-dev.local/wp-content/uploads/2025/11/20749-39045-glowing-subscribe-button.riv">glowing-subscribe-button.riv</option>
                <option value="http://kaizenstudio-dev.local/wp-content/uploads/2025/11/20749-39045-glowing-subscribe-button-1.riv">glowing-subscribe-button-1.riv</option>
                <option value="http://kaizenstudio-dev.local/wp-content/uploads/2025/11/24941-46557-expression-grid.riv">expression-grid.riv</option>
            </optgroup>
            <optgroup label="Test Files (Data Bindings)">
                <option value="http://kaizenstudio-dev.local/wp-content/uploads/2025/11/control-center-data-binding.riv">control-center-data-binding.riv</option>
                <option value="http://kaizenstudio-dev.local/wp-content/uploads/2025/11/data-binding-loaders-tutorial.riv">data-binding-loaders-tutorial.riv</option>
            </optgroup>
        </select>
    </div>

    <canvas id="canvas"></canvas>

    <div class="info">
        <h3>Console Output:</h3>
        <pre id="output"></pre>
    </div>

    <script>
        // Console logging helper
        const output = document.getElementById('output');
        const status = document.getElementById('status');
        const fileSelect = document.getElementById('fileSelect');
        let currentRive = null;

        function log(msg) {
            console.log(msg);
            output.textContent += msg + '\n';
        }

        function clearLog() {
            output.textContent = '';
        }

        function loadRiveFile(riveFileUrl) {
            clearLog();

            // Cleanup previous instance
            if (currentRive) {
                try {
                    currentRive.cleanup();
                } catch (e) {
                    log('Error cleaning up previous instance: ' + e.message);
                }
                currentRive = null;
            }

            log('=== Loading: ' + riveFileUrl.split('/').pop() + ' ===');
            log('Rive library loaded: ' + (typeof rive !== 'undefined'));

            if (typeof rive === 'undefined') {
                status.textContent = 'ERROR: Rive library not loaded!';
                log('ERROR: Rive library not loaded from CDN');
                return;
            }

            status.textContent = 'Rive library loaded OK';
            log('Rive object: ' + typeof rive);
            log('Rive.Rive constructor: ' + typeof rive.Rive);

            // Try to load a Rive file
            const canvas = document.getElementById('canvas');

            log('Attempting to load: ' + riveFileUrl);
            status.textContent = 'Loading Rive file...';

            try {
                currentRive = new rive.Rive({
                    src: riveFileUrl,
                    canvas: canvas,
                    autoplay: true,
                    autoBind: true, // Enable auto-binding of View Model
                    // Note: Don't specify stateMachines to allow auto-binding to work
                    onLoad: () => {
                        log('‚úÖ SUCCESS: Rive file loaded!');
                        log('State Machines: ' + JSON.stringify(currentRive.stateMachineNames));
                        log('Animations: ' + JSON.stringify(currentRive.animationNames));
                        log('Artboards: ' + JSON.stringify(currentRive.artboardNames));

                        // IMPORTANT: Check the 'contents' property!
                        log('\n=== FILE CONTENTS (Full Object Hierarchy) ===');
                        if (currentRive.contents) {
                            log('Contents property exists!');
                            console.log('üì¶ Full contents object:', currentRive.contents);

                            try {
                                log('Contents: ' + JSON.stringify(currentRive.contents, null, 2));
                            } catch (e) {
                                log('Cannot stringify contents (circular reference or too large)');
                                log('Check browser console for full object');
                            }
                        } else {
                            log('‚ùå No contents property found');
                        }

                        status.textContent = 'SUCCESS: Rive loaded!';

                        // === TEST DATA BINDINGS (View Model) ===
                        log('\n=== DATA BINDINGS (View Model) ===');

                        // Check if View Model methods exist
                        log('Checking View Model methods:');
                        log('  viewModelByName: ' + (typeof currentRive.viewModelByName === 'function' ? '‚úÖ' : '‚ùå'));
                        log('  defaultViewModel: ' + (typeof currentRive.defaultViewModel === 'function' ? '‚úÖ' : '‚ùå'));
                        log('  viewModelInstance: ' + (currentRive.viewModelInstance !== undefined ? '‚úÖ' : '‚ùå'));

                        // Try to get default View Model
                        try {
                            if (currentRive.defaultViewModel) {
                                const defaultVM = currentRive.defaultViewModel();
                                if (defaultVM) {
                                    log('‚úÖ DEFAULT VIEW MODEL FOUND!');
                                    console.log('üìä Default View Model:', defaultVM);

                                    // Try to get instance
                                    if (defaultVM.defaultInstance) {
                                        const vmi = defaultVM.defaultInstance();
                                        log('‚úÖ View Model Instance created!');
                                        console.log('üì¶ View Model Instance:', vmi);
                                    }
                                } else {
                                    log('‚ö†Ô∏è defaultViewModel() returned null/undefined');
                                }
                            }
                        } catch (e) {
                            log('‚ùå Error getting default view model: ' + e.message);
                        }

                        // Try to get auto-bound instance
                        try {
                            if (currentRive.viewModelInstance) {
                                log('‚úÖ AUTO-BOUND VIEW MODEL INSTANCE FOUND!');
                                const vmi = currentRive.viewModelInstance;
                                console.log('üì¶ Bound View Model Instance:', vmi);

                                // Try to inspect internal runtime instance for property names
                                log('Trying to get View Model property names...');

                                if (vmi._runtimeInstance) {
                                    console.log('üîç Runtime Instance:', vmi._runtimeInstance);

                                    // Try to get properties using getProperties method
                                    try {
                                        if (vmi._runtimeInstance.getProperties) {
                                            const properties = vmi._runtimeInstance.getProperties();
                                            log('‚úÖ FOUND PROPERTIES via getProperties()!');
                                            console.log('üìã Properties array:', properties);

                                            if (properties && properties.length > 0) {
                                                log('View Model has ' + properties.length + ' properties:');
                                                properties.forEach((prop, index) => {
                                                    log('  Property ' + (index + 1) + ':');
                                                    console.log('    Full property object:', prop);

                                                    // Try to get property details
                                                    for (let key in prop) {
                                                        if (typeof prop[key] !== 'function') {
                                                            log('    ' + key + ': ' + prop[key]);
                                                        }
                                                    }
                                                });
                                            } else {
                                                log('‚ö†Ô∏è getProperties() returned empty array');
                                            }
                                        } else {
                                            log('‚ö†Ô∏è No getProperties method on runtime instance');
                                        }
                                    } catch (e) {
                                        log('  Error calling getProperties: ' + e.message);
                                    }
                                }

                                // Try to access via the default View Model to see structure
                                try {
                                    const defaultVM = currentRive.defaultViewModel();
                                    console.log('üéØ Default View Model structure:', defaultVM);

                                    // Check if View Model has property definitions
                                    if (defaultVM._runtimeViewModel) {
                                        console.log('üîç Runtime View Model:', defaultVM._runtimeViewModel);
                                    }
                                } catch (e) {
                                    log('Error inspecting View Model structure: ' + e.message);
                                }

                                // Check contents for View Model metadata
                                log('\nChecking contents for View Model metadata...');
                                if (currentRive.contents && currentRive.contents.artboards) {
                                    const artboard = currentRive.contents.artboards[0];
                                    if (artboard.viewModels) {
                                        log('‚úÖ View Models found in contents!');
                                        log('View Models: ' + JSON.stringify(artboard.viewModels, null, 2));
                                    } else {
                                        log('‚ö†Ô∏è No viewModels property in contents.artboards[0]');

                                        // Log all artboard properties to see what's available
                                        log('Available artboard properties:');
                                        for (let prop in artboard) {
                                            log('  - ' + prop);
                                        }
                                    }
                                }
                            } else {
                                log('‚ö†Ô∏è No auto-bound viewModelInstance');
                            }
                        } catch (e) {
                            log('‚ùå Error getting view model instance: ' + e.message);
                        }

                        // === TEST TEXT RUNS ===
                        log('\n=== TEXT RUNS ===');
                        try {
                            if (currentRive.artboard) {
                                log('‚úÖ Artboard exists');
                                console.log('üé® Artboard object:', currentRive.artboard);

                                // Check for text runs
                                if (currentRive.artboard.textRuns) {
                                    log('‚úÖ textRuns property exists!');
                                    const textRuns = currentRive.artboard.textRuns();
                                    log('Text runs found: ' + textRuns.length);

                                    textRuns.forEach((textRun, index) => {
                                        log('  Text Run ' + (index + 1) + ':');
                                        log('    name: ' + textRun.name);
                                        log('    text: ' + textRun.text);
                                    });
                                } else {
                                    log('‚ö†Ô∏è No textRuns method on artboard');
                                    log('Trying alternative access methods...');

                                    // Try to find text runs another way
                                    if (currentRive.retrieveTextRun) {
                                        log('‚úÖ retrieveTextRun method exists on instance');
                                        log('Trying to retrieve text runs via retrieveTextRun...');

                                        // We need to know text run names to retrieve them
                                        // Try to get from contents
                                        if (currentRive.contents && currentRive.contents.artboards) {
                                            const artboard = currentRive.contents.artboards[0];
                                            if (artboard.textRuns) {
                                                log('Found text runs in contents:');
                                                artboard.textRuns.forEach(tr => {
                                                    log('  - ' + tr.name);

                                                    try {
                                                        const textRun = currentRive.retrieveTextRun(tr.name);
                                                        log('    Retrieved! Type: ' + typeof textRun);
                                                        console.log('    Text run object:', textRun);
                                                    } catch (e) {
                                                        log('    Error retrieving: ' + e.message);
                                                    }
                                                });
                                            } else {
                                                log('‚ö†Ô∏è No textRuns in contents.artboards[0]');
                                            }
                                        }

                                        // Also try getTextRunValue method
                                        if (currentRive.getTextRunValue) {
                                            log('‚úÖ getTextRunValue method also exists');
                                        }
                                    }
                                }
                            } else {
                                log('‚ùå No artboard object');
                            }
                        } catch (e) {
                            log('‚ùå Error inspecting text runs: ' + e.message);
                        }

                        // === TEST LOW-LEVEL ANIMATION OBJECTS ===
                        log('\n=== ANIMATION METADATA ===');
                        if (currentRive.artboard && currentRive.animationNames) {
                            log('Testing access to animation metadata...');

                            // Try to get first animation
                            const firstAnimName = currentRive.animationNames[0];
                            log('First animation: ' + firstAnimName);

                            try {
                                if (currentRive.artboard.animationByName) {
                                    const anim = currentRive.artboard.animationByName(firstAnimName);
                                    console.log('üé¨ Animation object:', anim);

                                    log('  Animation properties:');
                                    if (anim.duration !== undefined) log('    duration: ' + anim.duration + ' seconds');
                                    if (anim.fps !== undefined) log('    fps: ' + anim.fps);
                                    if (anim.loopValue !== undefined) {
                                        let loopMode = 'Unknown';
                                        if (anim.loopValue === 0) loopMode = 'OneShot';
                                        else if (anim.loopValue === 1) loopMode = 'Loop';
                                        else if (anim.loopValue === 2) loopMode = 'PingPong';
                                        log('    loopValue: ' + anim.loopValue + ' (' + loopMode + ')');
                                    }
                                    if (anim.workStart !== undefined) log('    workStart: ' + anim.workStart);
                                    if (anim.workEnd !== undefined) log('    workEnd: ' + anim.workEnd);
                                } else {
                                    log('  ‚ùå animationByName method not available');
                                }
                            } catch (e) {
                                log('  Error accessing animation: ' + e.message);
                            }
                        }

                        // Try to get inputs
                        if (currentRive.stateMachineNames && currentRive.stateMachineNames.length > 0) {
                            currentRive.stateMachineNames.forEach(smName => {
                                log('\nState Machine: ' + smName);
                                try {
                                    const inputs = currentRive.stateMachineInputs(smName);
                                    log('  Inputs raw: ' + JSON.stringify(inputs));
                                    log('  Inputs type: ' + typeof inputs);
                                    log('  Inputs is array: ' + Array.isArray(inputs));

                                    if (inputs && inputs.length > 0) {
                                        log('  ‚úÖ FOUND ' + inputs.length + ' INPUTS:');
                                        inputs.forEach(input => {
                                            // Decode input type
                                            let typeName = 'Unknown';
                                            if (input.type === 56) typeName = 'Number';
                                            else if (input.type === 57) typeName = 'Boolean';
                                            else if (input.type === 58) typeName = 'Trigger';

                                            log('    - ' + input.name + ' (type: ' + typeName + ' [' + input.type + '])');
                                            log('      value: ' + input.value);
                                            if (input.fire) log('      has fire() method: yes');
                                        });
                                    } else {
                                        log('  ‚ùå No inputs found (State Machine har ingen eksponerede inputs)');
                                    }
                                } catch (e) {
                                    log('  ‚ùå Error getting inputs: ' + e.message);
                                }
                            });
                        } else {
                            log('\n‚ùå No state machines found');
                        }
                    },
                    onLoadError: (err) => {
                        log('‚ùå ERROR loading Rive file');
                        log('Error type: ' + typeof err);
                        log('Error: ' + JSON.stringify(err));
                        status.textContent = 'ERROR loading Rive file';
                    }
                });

                log('Rive instance created');

            } catch (e) {
                log('‚ùå EXCEPTION: ' + e.message);
                log('Stack: ' + e.stack);
                status.textContent = 'ERROR: ' + e.message;
            }
        }

        // Event listener for file selection
        fileSelect.addEventListener('change', function(e) {
            const selectedFile = e.target.value;
            if (selectedFile) {
                loadRiveFile(selectedFile);
            }
        });

        // Load first file on page load
        loadRiveFile(fileSelect.value);
    </script>
</body>
</html>
